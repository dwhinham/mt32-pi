diff --git a/CMakeLists.txt b/CMakeLists.txt
index 595e6a4c..2b0ed9c1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -442,6 +442,7 @@ if ( ASTYLE )
     )
 endif(ASTYLE)
 
+if(FALSE)
 if(NOT enable-pkgconfig)
 
     FIND_LIBRARY( GLIB_LIB NAMES glib glib-2.0 PATH GLIB_LIBRARY_DIR )
@@ -600,6 +601,7 @@ else(NOT enable-pkgconfig)
     endif ( enable-readline )
 
 endif(NOT enable-pkgconfig)
+endif()
 
 unset ( AUFILE_SUPPORT CACHE )
 if ( enable-aufile )
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 356bb734..f44fc7f0 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -203,23 +203,23 @@
     synth/fluid_tuning.h
     synth/fluid_voice.c
     synth/fluid_voice.h
-    midi/fluid_midi.c
-    midi/fluid_midi.h
-    midi/fluid_midi_router.c
-    midi/fluid_midi_router.h
-    midi/fluid_seqbind.c
-    midi/fluid_seqbind_notes.cpp
-    midi/fluid_seq.c
-    midi/fluid_seq_queue.cpp
-    drivers/fluid_adriver.c
-    drivers/fluid_adriver.h
-    drivers/fluid_mdriver.c
-    drivers/fluid_mdriver.h
-    bindings/fluid_cmd.c
-    bindings/fluid_cmd.h
-    bindings/fluid_filerenderer.c
-    bindings/fluid_ladspa.c
-    bindings/fluid_ladspa.h
+    #midi/fluid_midi.c
+    #midi/fluid_midi.h
+    #midi/fluid_midi_router.c
+    #midi/fluid_midi_router.h
+    #midi/fluid_seqbind.c
+    #midi/fluid_seqbind_notes.cpp
+    #midi/fluid_seq.c
+    #midi/fluid_seq_queue.cpp
+    #drivers/fluid_adriver.c
+    #drivers/fluid_adriver.h
+    #drivers/fluid_mdriver.c
+    #drivers/fluid_mdriver.h
+    #bindings/fluid_cmd.c
+    #bindings/fluid_cmd.h
+    #bindings/fluid_filerenderer.c
+    #bindings/fluid_ladspa.c
+    #bindings/fluid_ladspa.h
 )
 
 set ( public_HEADERS
diff --git a/src/sfloader/fluid_sfont.c b/src/sfloader/fluid_sfont.c
index 140fc3c5..5780367b 100644
--- a/src/sfloader/fluid_sfont.c
+++ b/src/sfloader/fluid_sfont.c
@@ -22,6 +22,7 @@
 #include "fluid_sys.h"
 
 
+#if 0
 void *default_fopen(const char *path)
 {
     const char* msg;
@@ -80,6 +81,13 @@
 
     return FLUID_OK;
 }
+#endif
+
+void *default_fopen(const char *path);
+int default_fclose(void *handle);
+fluid_long_long_t default_ftell(void *handle);
+int safe_fread(void *buf, fluid_long_long_t count, void *fd);
+int safe_fseek(void *fd, fluid_long_long_t ofs, int whence);
 
 #undef PRIi64
 
@@ -147,7 +155,7 @@
     loader->data = data;
     return FLUID_OK;
 }
-
+//#endif
 /**
  * Obtain private data previously set with fluid_sfloader_set_data().
  *
@@ -202,6 +210,7 @@
     // NOTE: if we ever make the instpatch loader public, this may return FLUID_FAILED
     return FLUID_OK;
 }
+//#endif
 
 /**
  * Creates a new virtual SoundFont instance structure.
diff --git a/src/synth/fluid_synth.c b/src/synth/fluid_synth.c
index 1e0b29fb..cc3e0cc1 100644
--- a/src/synth/fluid_synth.c
+++ b/src/synth/fluid_synth.c
@@ -95,7 +95,9 @@ static int fluid_synth_render_blocks(fluid_synth_t *synth, int blockcount);
 static fluid_voice_t *fluid_synth_free_voice_by_kill_LOCAL(fluid_synth_t *synth);
 static void fluid_synth_kill_by_exclusive_class_LOCAL(fluid_synth_t *synth,
         fluid_voice_t *new_voice);
+#if 0
 static int fluid_synth_sfunload_callback(void *data, unsigned int msec);
+#endif
 static fluid_tuning_t *fluid_synth_get_tuning(fluid_synth_t *synth,
         int bank, int prog);
 static int fluid_synth_replace_tuning_LOCK(fluid_synth_t *synth,
@@ -1127,6 +1129,7 @@ delete_fluid_synth(fluid_synth_t *synth)
 
     /* wait for and delete all the lazy sfont unloading timers */
 
+#if 0
     for(list = synth->fonts_to_be_unloaded; list; list = fluid_list_next(list))
     {
         fluid_timer_t* timer = fluid_list_get(list);
@@ -1137,6 +1140,7 @@ delete_fluid_synth(fluid_synth_t *synth)
     }
 
     delete_fluid_list(synth->fonts_to_be_unloaded);
+#endif
 
     if(synth->channel != NULL)
     {
@@ -4890,14 +4894,17 @@ fluid_synth_sfont_unref(fluid_synth_t *synth, fluid_sfont_t *sfont)
         {
             FLUID_LOG(FLUID_DBG, "Unloaded SoundFont");
         } /* spin off a timer thread to unload the sfont later (SoundFont loader blocked unload) */
+#if 0
         else
         {
             fluid_timer_t* timer = new_fluid_timer(100, fluid_synth_sfunload_callback, sfont, TRUE, FALSE, FALSE);
             synth->fonts_to_be_unloaded = fluid_list_prepend(synth->fonts_to_be_unloaded, timer);
         }
+#endif
     }
 }
 
+#if 0
 /* Callback to continually attempt to unload a SoundFont,
  * only if a SoundFont loader blocked the unload operation */
 static int
@@ -4915,6 +4922,7 @@ fluid_synth_sfunload_callback(void *data, unsigned int msec)
         return TRUE;
     }
 }
+#endif
 
 /**
  * Reload a SoundFont.  The SoundFont retains its ID and index on the SoundFont stack.
@@ -6435,6 +6443,7 @@ fluid_synth_get_gen(fluid_synth_t *synth, int chan, int param)
     FLUID_API_RETURN(result);
 }
 
+#if 0
 /**
  * Handle MIDI event from MIDI router, used as a callback function.
  * @param data FluidSynth instance
@@ -6491,6 +6500,7 @@ fluid_synth_handle_midi_event(void *data, fluid_midi_event_t *event)
 
     return FLUID_FAILED;
 }
+#endif
 
 /**
  * Create and start voices using an arbitrary preset and a MIDI note on event.
diff --git a/src/synth/fluid_synth.h b/src/synth/fluid_synth.h
index 59980dd8..fc18f8e7 100644
--- a/src/synth/fluid_synth.h
+++ b/src/synth/fluid_synth.h
@@ -127,7 +127,9 @@ struct _fluid_synth_t
     fluid_list_t *loaders;             /**< the SoundFont loaders */
     fluid_list_t *sfont;          /**< List of fluid_sfont_info_t for each loaded SoundFont (remains until SoundFont is unloaded) */
     int sfont_id;             /**< Incrementing ID assigned to each loaded SoundFont */
+#if 0
     fluid_list_t *fonts_to_be_unloaded; /**< list of timers that try to unload a soundfont */
+#endif
 
     float gain;                        /**< master gain */
     fluid_channel_t **channel;         /**< the channels */
diff --git a/src/utils/fluid_settings.c b/src/utils/fluid_settings.c
index 979493f2..e1859ef6 100644
--- a/src/utils/fluid_settings.c
+++ b/src/utils/fluid_settings.c
@@ -328,11 +328,13 @@ fluid_settings_init(fluid_settings_t *settings)
     fluid_return_if_fail(settings != NULL);
 
     fluid_synth_settings(settings);
+#if 0
     fluid_shell_settings(settings);
     fluid_player_settings(settings);
     fluid_file_renderer_settings(settings);
     fluid_audio_driver_settings(settings);
     fluid_midi_driver_settings(settings);
+#endif
 }
 
 static int
diff --git a/src/utils/fluid_sys.c b/src/utils/fluid_sys.c
index 9da394e7..42abbabf 100644
--- a/src/utils/fluid_sys.c
+++ b/src/utils/fluid_sys.c
@@ -50,6 +50,7 @@
 #define FLUID_SYS_TIMER_HIGH_PRIO_LEVEL         10
 
 
+#if 0
 typedef struct
 {
     fluid_thread_func_t func;
@@ -82,6 +83,7 @@
 
 
 static int fluid_istream_gets(fluid_istream_t in, char *buf, int len);
+#endif
 
 static fluid_log_function_t fluid_log_function[LAST_LOG_LEVEL] =
 {
@@ -198,6 +200,7 @@
     return FLUID_FAILED;
 }
 
+#if 0
 void* fluid_alloc(size_t len)
 {
     void* ptr = malloc(len);
@@ -295,6 +298,7 @@
 {
     free(ptr);
 }
+#endif
 
 /**
  * An improved strtok, still trashes the input string, but is portable and
@@ -372,6 +376,7 @@
     return token;
 }
 
+#if 0
 /**
  * Suspend the execution of the current thread for the specified amount of time.
  * @param milliseconds to wait.
@@ -380,6 +385,7 @@
 {
     g_usleep(msecs * 1000);
 }
+#endif
 
 /**
  * Get time in milliseconds to be used in relative timing operations.
@@ -400,6 +406,7 @@
     return (unsigned int)((now - initial_time) / 1000.0f);
 }
 
+#if 0
 /**
  * Get time in microseconds to be used in relative timing operations.
  * @return time in microseconds.
@@ -1754,6 +1761,7 @@
     
     return handle;
 }
+#endif
 
 fluid_long_long_t fluid_file_tell(FILE* f)
 {
diff --git a/src/utils/fluid_sys.h b/src/utils/fluid_sys.h
index 7c7db764..f76d943b 100644
--- a/src/utils/fluid_sys.h
+++ b/src/utils/fluid_sys.h
@@ -157,7 +157,12 @@ typedef gintptr  intptr_t;
 #include <gmodule.h>
 #endif
 
+#if 0
 #include <glib/gstdio.h>
+#endif
+
+#define TRUE 1
+#define FALSE 0
 
 /**
  * Macro used for safely accessing a message from a GError and using a default
@@ -179,10 +184,17 @@ typedef gintptr  intptr_t;
 #define FLUID_INT_TO_POINTER(x)   ((void *)(intptr_t)(x))
 
 /* Endian detection */
+#if 0
 #define FLUID_IS_BIG_ENDIAN       (G_BYTE_ORDER == G_BIG_ENDIAN)
 
 #define FLUID_LE32TOH(x)          GINT32_FROM_LE(x)
 #define FLUID_LE16TOH(x)          GINT16_FROM_LE(x)
+#endif
+
+#define FLUID_IS_BIG_ENDIAN       FALSE
+
+#define FLUID_LE32TOH(x)          x
+#define FLUID_LE16TOH(x)          x
 
 #if FLUID_IS_BIG_ENDIAN
 #define FLUID_FOURCC(_a, _b, _c, _d) \
@@ -225,6 +237,7 @@ typedef int (*fluid_timer_callback_t)(void *data, unsigned int msec);
 
 typedef struct _fluid_timer_t fluid_timer_t;
 
+#if 0
 fluid_timer_t *new_fluid_timer(int msec, fluid_timer_callback_t callback,
                                void *data, int new_thread, int auto_destroy,
                                int high_priority);
@@ -238,9 +251,11 @@ long fluid_timer_get_interval(const fluid_timer_t * timer);
 // Macros to use for pre-processor if statements to test which Glib thread API we have (pre or post 2.32)
 #define NEW_GLIB_THREAD_API   GLIB_CHECK_VERSION(2,32,0)
 #define OLD_GLIB_THREAD_API  !GLIB_CHECK_VERSION(2,32,0)
+#endif
 
 /* Muteces */
 
+#if 0
 #if NEW_GLIB_THREAD_API
 
 /* glib 2.32 and newer */
@@ -377,10 +392,12 @@ typedef GStaticPrivate fluid_private_t;
 } while(0)
 
 #endif
+#endif
 
 
 /* Atomic operations */
 
+#if 0
 #define fluid_atomic_int_inc(_pi) g_atomic_int_inc(_pi)
 #define fluid_atomic_int_get(_pi) g_atomic_int_get(_pi)
 #define fluid_atomic_int_set(_pi, _val) g_atomic_int_set(_pi, _val)
@@ -422,10 +439,62 @@ fluid_atomic_float_get(volatile float *fptr)
     memcpy(&fval, &ival, 4);
     return fval;
 }
+#endif
 
+#define fluid_atomic_int_inc(atomic) \
+    (__extension__({ __atomic_fetch_add((atomic), 1, __ATOMIC_SEQ_CST); }))
+
+#define fluid_atomic_int_get(atomic)                                  \
+    (__extension__({                                                  \
+        int gaig_temp;                                                \
+        __atomic_load((int *)(atomic), &gaig_temp, __ATOMIC_SEQ_CST); \
+        gaig_temp;                                                    \
+    }))
+
+#define fluid_atomic_int_set(atomic, newval)                           \
+    (__extension__({                                                   \
+        int gais_temp = (int)(newval);                                 \
+        __atomic_store((int *)(atomic), &gais_temp, __ATOMIC_SEQ_CST); \
+    }))
+
+#define fluid_atomic_int_compare_and_exchange(atomic, oldval, newval)                                                \
+    (__extension__({                                                                                                 \
+        int gaicae_oldval = (oldval);                                                                                \
+        __atomic_compare_exchange_n((atomic), &gaicae_oldval, (newval), FALSE, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST) ? \
+        TRUE :                                                                                                       \
+        FALSE;                                                                                                       \
+    }))
+
+#define fluid_atomic_int_exchange_and_add(atomic, val) fluid_atomic_int_add(atomic, val)
+
+#define fluid_atomic_int_add(atomic, val) \
+    (__extension__({ (int)__atomic_fetch_add((atomic), (val), __ATOMIC_SEQ_CST); }))
+
+#define fluid_atomic_float_get(atomic) (*atomic)
+#define fluid_atomic_float_set(atomic, newval) (*atomic = newval)
+
+typedef char fluid_mutex_t;
+#define FLUID_MUTEX_INIT { 0 }
+#define fluid_mutex_init(mutex) (void)mutex
+#define fluid_mutex_destroy(mutex) (void)mutex
+#define fluid_mutex_lock(mutex) (void)mutex
+#define fluid_mutex_unlock(mutex) (void)mutex
+
+typedef char fluid_rec_mutex_t;
+#define fluid_rec_mutex_init(mutex) (void)mutex
+#define fluid_rec_mutex_destroy(mutex) (void)mutex
+#define fluid_rec_mutex_lock(mutex) (void)mutex
+#define fluid_rec_mutex_unlock(mutex) (void)mutex
+
+typedef void* fluid_private_t;
+#define fluid_private_init(priv) memset(&priv, 0, sizeof (priv))
+#define fluid_private_get(priv) ((void*)priv)
+#define fluid_private_set(priv, data) (priv = (void*)data)
+#define fluid_private_free(priv)
 
 /* Threads */
 
+#if 0
 /* other thread implementations might change this for their needs */
 typedef void *fluid_thread_return_t;
 /* static return value for thread functions which requires a return value */
@@ -443,6 +512,9 @@ fluid_thread_t *new_fluid_thread(const char *name, fluid_thread_func_t func, voi
 void delete_fluid_thread(fluid_thread_t *thread);
 void fluid_thread_self_set_prio(int prio_level);
 int fluid_thread_join(fluid_thread_t *thread);
+#endif
+
+typedef char fluid_thread_t;
 
 /* Dynamic Module Loading, currently only used by LADSPA subsystem */
 #ifdef LADSPA
@@ -481,6 +553,7 @@ fluid_istream_t fluid_socket_get_istream(fluid_socket_t sock);
 fluid_ostream_t fluid_socket_get_ostream(fluid_socket_t sock);
 
 /* File access */
+#if 0
 #define fluid_stat(_filename, _statbuf)   g_stat((_filename), (_statbuf))
 #if !GLIB_CHECK_VERSION(2, 26, 0)
     /* GStatBuf has not been introduced yet, manually typedef to what they had at that time:
@@ -499,6 +572,10 @@ fluid_ostream_t fluid_socket_get_ostream(fluid_socket_t sock);
 #else
 typedef GStatBuf fluid_stat_buf_t;
 #endif
+#endif
+
+#define fluid_stat(filename, buf) stat(filename, buf)
+typedef struct stat fluid_stat_buf_t;
 
 FILE* fluid_file_open(const char* filename, const char** errMsg);
 
diff --git a/src/utils/fluidsynth_priv.h b/src/utils/fluidsynth_priv.h
index 0626bace..57402f27 100644
--- a/src/utils/fluidsynth_priv.h
+++ b/src/utils/fluidsynth_priv.h
@@ -29,7 +29,9 @@
 #ifndef _FLUIDSYNTH_PRIV_H
 #define _FLUIDSYNTH_PRIV_H
 
+#if 0
 #include <glib.h>
+#endif
 
 #include "config.h"
 
@@ -182,13 +184,14 @@ typedef void (*fluid_rvoice_function_t)(void *obj, const fluid_rvoice_param_t pa
 
 /* Memory allocation */
 #define FLUID_MALLOC(_n)             fluid_alloc(_n)
-#define FLUID_REALLOC(_p,_n)         realloc(_p,_n)
+#define FLUID_REALLOC(_p,_n)         fluid_realloc(_p,_n)
 #define FLUID_FREE(_p)               fluid_free(_p)
 #define FLUID_NEW(_t)                (_t*)FLUID_MALLOC(sizeof(_t))
 #define FLUID_ARRAY_ALIGNED(_t,_n,_a) (_t*)FLUID_MALLOC((_n)*sizeof(_t) + ((unsigned int)_a - 1u))
 #define FLUID_ARRAY(_t,_n)           FLUID_ARRAY_ALIGNED(_t,_n,1u)
 
 void* fluid_alloc(size_t len);
+void* fluid_realloc(void* ptr, size_t len);
 
 /* File access */
 #define FLUID_FOPEN(_f,_m)           fopen(_f,_m)
@@ -281,8 +284,12 @@ do { strncpy(_dst,_src,_n); \
 #define FLUID_ASSERT(a)
 #endif
 
+#if 0
 #define FLUID_LIKELY G_LIKELY
 #define FLUID_UNLIKELY G_UNLIKELY
+#endif
+#define FLUID_LIKELY(cond) __builtin_expect((cond), 1)
+#define FLUID_UNLIKELY(cond) __builtin_expect((cond), 0)
 
 /* Misc */
 #if defined(__INTEL_COMPILER)
